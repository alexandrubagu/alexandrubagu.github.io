<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PostgreSQL Partitioning with pg_partman: Automate Partition Management - B창gu Alexandru Bogdan</title>
  <meta name="description" content="Master PostgreSQL partitioning with pg_partman. Learn how to automate time-based partition creation, implement retention policies, and optimize large table performance. Complete guide with practical examples." />

  <!-- PWA and Mobile -->
  <meta name="theme-color" content="#1e293b">

  <!-- JSON-LD Structured Data -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "headline": "PostgreSQL Partitioning with pg_partman: Automate Partition Management",
    "description": "Master PostgreSQL partitioning with pg_partman. Learn how to automate time-based partition creation, implement retention policies, and optimize large table performance. Complete guide with practical examples.",
    "image": "https://alexandrubagu.github.io/profile.jpg",
    "author": {
      "@type": "Person",
      "name": "B창gu Alexandru Bogdan",
      "url": "https://alexandrubagu.github.io"
    },
    "publisher": {
      "@type": "Person",
      "name": "B창gu Alexandru Bogdan",
      "logo": {
        "@type": "ImageObject",
        "url": "https://alexandrubagu.github.io/profile.jpg"
      }
    },
    "datePublished": "2025-12-03T08:00:00+08:00",
    "dateModified": "2025-12-03T08:00:00+08:00",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "https://alexandrubagu.github.io/blog/pg-partman-guide.html"
    },
    "keywords": "pg_partman, PostgreSQL partitioning, partition management, time-based partitions, retention policies, database performance, PostgreSQL optimization, partition automation",
    "articleSection": "Database",
    "inLanguage": "en-US",
    "about": [
      {
        "@type": "Thing",
        "name": "PostgreSQL Database"
      },
      {
        "@type": "Thing",
        "name": "Table Partitioning"
      },
      {
        "@type": "Thing",
        "name": "Performance Optimization"
      },
      {
        "@type": "Thing",
        "name": "pg_partman Extension"
      }
    ]
  }
  </script>

  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "TechArticle",
    "name": "PostgreSQL pg_partman Partition Management Guide",
    "description": "Technical guide for using pg_partman to automate PostgreSQL table partitioning and manage large datasets efficiently",
    "proficiencyLevel": "Intermediate",
    "dependencies": "PostgreSQL 12.5+, pg_partman extension, pg_cron",
    "author": {
      "@type": "Person",
      "name": "B창gu Alexandru Bogdan"
    }
  }
  </script>

  <!-- Performance optimizations -->
  <link rel="icon" href="/favicon.ico" sizes="any">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="dns-prefetch" href="https://cdn.tailwindcss.com">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">

  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: {
            sans: ['Inter', 'system-ui', 'sans-serif'],
          },
          colors: {
            primary: 'rgb(59, 130, 246)',
            'primary-foreground': 'rgb(255, 255, 255)',
            background: 'rgb(255, 255, 255)',
            foreground: 'rgb(30, 41, 59)',
            muted: 'rgb(241, 245, 249)',
            'muted-foreground': 'rgb(100, 116, 139)',
            border: 'rgb(226, 232, 240)',
            slate: {
              50: 'rgb(248, 250, 252)',
              100: 'rgb(241, 245, 249)',
              200: 'rgb(226, 232, 240)',
              300: 'rgb(203, 213, 225)',
              400: 'rgb(148, 163, 184)',
              500: 'rgb(100, 116, 139)',
              600: 'rgb(71, 85, 105)',
              700: 'rgb(51, 65, 85)',
              800: 'rgb(30, 41, 59)',
              900: 'rgb(15, 23, 42)',
            },
          },
        },
      },
    }
  </script>

  <style>
    html {
      scroll-behavior: smooth;
    }

    section {
      scroll-margin-top: 5rem;
    }

    .gradient-hero {
      background: linear-gradient(135deg, rgb(15, 23, 42) 0%, rgb(30, 41, 59) 100%);
    }

    .gradient-primary {
      background: linear-gradient(135deg, rgb(59, 130, 246) 0%, rgb(96, 165, 250) 100%);
    }

    .gradient-subtle {
      background: linear-gradient(180deg, rgb(255, 255, 255) 0%, rgb(248, 250, 252) 100%);
    }

    .line-clamp-2 {
      display: -webkit-box;
      -webkit-line-clamp: 2;
      line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    .line-clamp-3 {
      display: -webkit-box;
      -webkit-line-clamp: 3;
      line-clamp: 3;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    article code {
      background-color: #f1f5f9;
      padding: 0.125rem 0.5rem;
      border-radius: 0.25rem;
      font-size: 0.875rem;
    }

    article pre {
      background-color: #1e293b;
      color: #e2e8f0;
      padding: 1rem;
      border-radius: 0.5rem;
      overflow-x: auto;
      margin-bottom: 1rem;
    }

    article pre code {
      background-color: transparent;
      padding: 0;
      color: #e2e8f0;
      font-family: 'Courier New', monospace;
    }

    article h2 {
      font-size: 1.875rem;
      font-weight: 700;
      margin-top: 2rem;
      margin-bottom: 1rem;
      color: #1e293b;
    }

    article p {
      margin-bottom: 1rem;
      line-height: 1.75;
      color: #475569;
    }

    article ul {
      margin-left: 1.5rem;
      margin-bottom: 1rem;
    }

    article li {
      margin-bottom: 0.5rem;
      color: #475569;
      line-height: 1.75;
    }

    article strong {
      color: #1e293b;
      font-weight: 600;
    }
  </style>

  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-WK8MJ0B6R6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-WK8MJ0B6R6');
  </script>
</head>
<body class="bg-white text-slate-900">
  <!-- Navigation -->
  <nav id="navbar" class="fixed top-0 left-0 right-0 z-50 bg-white/95 backdrop-blur-md shadow-md transition-all duration-300">
    <div class="container mx-auto px-4">
      <div class="flex items-center justify-between h-16">
        <a href="/index.html" id="navbar-logo" class="text-xl font-bold text-slate-900 hover:text-primary transition-colors">
          Alexandru Bogdan
        </a>

        <!-- Desktop Navigation -->
        <div class="hidden md:flex items-center space-x-1" id="desktop-nav">
          <a href="/index.html#home" class="px-3 py-2 text-sm font-medium text-slate-900 hover:text-primary transition-colors">Home</a>
          <a href="/index.html#experience" class="px-3 py-2 text-sm font-medium text-slate-900 hover:text-primary transition-colors">Experience</a>
          <a href="/index.html#projects" class="px-3 py-2 text-sm font-medium text-slate-900 hover:text-primary transition-colors">Projects</a>
          <a href="/blog.html" class="px-3 py-2 text-sm font-medium text-slate-900 hover:text-primary transition-colors">Blog</a>
          <a href="/index.html#contact" class="px-3 py-2 text-sm font-medium text-slate-900 hover:text-primary transition-colors">Contact</a>
        </div>

        <!-- Mobile Menu Button -->
        <button id="mobile-menu-btn" class="md:hidden p-2 text-slate-900">
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
          </svg>
        </button>
      </div>

      <!-- Mobile Navigation -->
      <div id="mobile-menu" class="hidden md:hidden py-4 border-t border-slate-200">
        <div class="flex flex-col space-y-2" id="mobile-nav">
          <a href="/index.html#home" class="px-3 py-2 text-sm font-medium text-slate-900 hover:text-primary hover:bg-slate-100 rounded-md transition-colors">Home</a>
          <a href="/index.html#experience" class="px-3 py-2 text-sm font-medium text-slate-900 hover:text-primary hover:bg-slate-100 rounded-md transition-colors">Experience</a>
          <a href="/index.html#projects" class="px-3 py-2 text-sm font-medium text-slate-900 hover:text-primary hover:bg-slate-100 rounded-md transition-colors">Projects</a>
          <a href="/blog.html" class="px-3 py-2 text-sm font-medium text-slate-900 hover:text-primary hover:bg-slate-100 rounded-md transition-colors">Blog</a>
          <a href="/index.html#contact" class="px-3 py-2 text-sm font-medium text-slate-900 hover:text-primary hover:bg-slate-100 rounded-md transition-colors">Contact</a>
        </div>
      </div>
    </div>
  </nav>

  <article class="container mx-auto px-4 pt-24 pb-16">
    <div class="max-w-3xl mx-auto">
      <header class="mb-12">
        <span class="px-3 py-1 bg-slate-200 text-slate-700 text-xs rounded-full mb-4 inline-block">Database</span>
        <h1 class="text-4xl md:text-5xl font-bold mb-6 text-slate-900">
          PostgreSQL Partitioning with pg_partman: Automate Partition Management
        </h1>
        <div class="flex items-center gap-6 text-slate-600">
          <div class="flex items-center gap-2">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
            </svg>
            <span class="text-sm">December 3, 2025</span>
          </div>
          <div class="flex items-center gap-2">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
            <span class="text-sm">7 min read</span>
          </div>
        </div>
      </header>

      <div class="prose max-w-none text-slate-900">
        <p class="mb-4 text-lg">
          Large datasets become unwieldy fast. As your tables grow to millions or billions of rows, query performance degrades, index maintenance becomes expensive, and operations like VACUUM grow painfully slow. This is where PostgreSQL partitioning shines, but manual partition management is tedious and error-prone. pg_partman eliminates this burden by automating partition creation, maintenance, and cleanup.
        </p>

        <h2>What is pg_partman?</h2>
        <p>
          pg_partman is a PostgreSQL extension that automates the creation and maintenance of table partitions. Rather than manually creating new partitions and managing retention, pg_partman handles this complexity through time-based and serial-based partitioning strategies.
        </p>
        <p>
          Partitioning splits large tables into smaller, more manageable chunks based on a partition key. PostgreSQL then routes queries to only relevant partitions, dramatically improving performance for large datasets. pg_partman automates this architecture, creating new partitions on schedule and removing old data according to retention policies.
        </p>
        <p>
          Available for PostgreSQL 12.5 and newer, including AWS RDS, pg_partman pairs naturally with pg_cron to schedule maintenance tasks that run automatically in the background.
        </p>

        <h2>Why Partition Large Tables?</h2>
        <p>
          Partitioning addresses critical challenges with massive datasets:
        </p>
        <ul>
          <li><strong>Improved query performance:</strong> PostgreSQL only scans partitions containing relevant data, dramatically reducing I/O</li>
          <li><strong>Efficient index maintenance:</strong> Smaller indexes on individual partitions are faster to build and maintain than monolithic indexes</li>
          <li><strong>Faster VACUUM operations:</strong> Vacuuming smaller partitions takes significantly less time and resource overhead</li>
          <li><strong>Simplified archival and retention:</strong> Drop entire old partitions instead of deleting rows from massive tables</li>
          <li><strong>Parallel query execution:</strong> PostgreSQL can parallelize scans across multiple partitions</li>
        </ul>
        <p>
          Without partitioning, operations on a billion-row table lock the entire dataset. With proper partitioning, you operate on manageable chunks while keeping the database responsive.
        </p>

        <h2>Getting Started with pg_partman</h2>
        <p>
          First, install the pg_partman extension on your PostgreSQL server. For AWS RDS, it's available in the extensions list. For self-hosted PostgreSQL, install via your package manager or compile from source.
        </p>
        <p>
          Once installed, create the extension in your database:
        </p>
        <pre><code>CREATE EXTENSION IF NOT EXISTS pg_partman;</code></pre>
        <p>
          pg_partman creates schema objects that manage partitions. Verify the installation by checking for the pg_partman schema:
        </p>
        <pre><code>SELECT schemaname FROM pg_namespace
WHERE schemaname = 'pg_partman';</code></pre>

        <h2>Creating Partitioned Tables</h2>
        <p>
          The simplest approach is to start with a new table. Define your table structure first, then use pg_partman's <code>create_parent</code> function to enable partitioning:
        </p>
        <pre><code>-- Create your base table
CREATE TABLE events (
  id BIGSERIAL NOT NULL,
  created_at TIMESTAMP NOT NULL,
  event_type VARCHAR(50),
  user_id BIGINT,
  payload JSONB,
  PRIMARY KEY (id, created_at)
);

-- Enable time-based partitioning
SELECT pg_partman.create_parent(
  p_parent_table => 'public.events',
  p_control => 'created_at',
  p_type => 'range',
  p_interval => 'daily',
  p_premake => 7
);</code></pre>
        <p>
          This creates daily partitions with 7 days pre-created ahead of time. The control column (<code>created_at</code>) determines which partition receives each row. The <code>p_premake => 7</code> parameter ensures new partitions exist before data arrives, preventing write failures on the boundary dates.
        </p>
        <p>
          For time intervals, use <code>'daily'</code>, <code>'monthly'</code>, or <code>'yearly'</code>. For serial-based partitioning on integer IDs, use <code>p_interval => 1000000</code> to create new partitions every 1 million rows.
        </p>

        <h2>Automating Partition Maintenance</h2>
        <p>
          Partitions must be created regularly and old partitions removed according to retention policy. pg_partman integrates seamlessly with pg_cron for automated maintenance. First, ensure pg_cron is installed and enabled:
        </p>
        <pre><code>CREATE EXTENSION IF NOT EXISTS pg_cron;
GRANT USAGE ON SCHEMA pg_cron TO postgres;</code></pre>
        <p>
          Now schedule the maintenance function to run daily:
        </p>
        <pre><code>SELECT cron.schedule(
  'maintain-events-partitions',
  '5 0 * * *',  -- Run at 00:05 UTC daily
  'SELECT pg_partman.maintain_partition_table(''public.events'')'
);</code></pre>
        <p>
          The cron expression follows standard Unix cron format. This schedule creates new partitions and removes old ones according to your retention policy, ensuring your partition structure stays ahead of data growth.
        </p>

        <h2>Setting Retention Policies</h2>
        <p>
          Retention policies automatically remove old data. Define how long to keep partitions using the <code>set_config_parameters</code> function:
        </p>
        <pre><code>-- Keep data for 90 days
UPDATE pg_partman.part_config
SET retention = '90 days',
    retention_keep_behavior = 'DETACH'
WHERE parent_table = 'public.events';</code></pre>
        <p>
          The <code>retention_keep_behavior</code> option determines what happens to expired partitions. <code>'DETACH'</code> removes them from the partition structure but preserves the data if you need to archive it. <code>'DROP'</code> immediately removes the partition and its data.
        </p>
        <p>
          You can also retain a minimum number of partitions even if they're old:
        </p>
        <pre><code>UPDATE pg_partman.part_config
SET retention = '90 days',
    retention_keep_number = 30
WHERE parent_table = 'public.events';</code></pre>
        <p>
          This keeps at least 30 partitions regardless of age, useful for ensuring historical data availability beyond the standard retention window.
        </p>

        <h2>Monitoring Partition Health</h2>
        <p>
          Query the <code>part_config</code> table to monitor partition status:
        </p>
        <pre><code>SELECT parent_table,
       partition_interval,
       retention,
       retention_keep_number,
       last_partition,
       last_run_time
FROM pg_partman.part_config
WHERE parent_table = 'public.events';</code></pre>
        <p>
          Check the <code>part_info_parent</code> view to see all existing partitions:
        </p>
        <pre><code>SELECT partition_name,
       partition_expression,
       pg_size_pretty(pg_relation_size(schemaname||'.'||partition_name)) AS size
FROM pg_partman.part_info_parent
WHERE parent_table = 'public.events'
ORDER BY partition_name;</code></pre>
        <p>
          This reveals partition distribution, sizes, and helps identify imbalances or anomalies in your data.
        </p>

        <h2>Best Practices</h2>
        <p>
          Successful partitioning requires thoughtful design:
        </p>
        <ul>
          <li>Choose partition keys that align with your query patterns - typically timestamps for time-series data</li>
          <li>Include the partition key in your primary key to satisfy PostgreSQL's constraint requirements</li>
          <li>Pre-create 7-10 days of partitions to prevent insertion failures on boundaries</li>
          <li>Set retention policies conservatively to avoid surprise data loss</li>
          <li>Test maintenance scripts on staging environments before production deployment</li>
          <li>Monitor partition creation and removal logs to catch issues early</li>
          <li>Update index strategies - individual partition indexes are often more efficient than global ones</li>
        </ul>
        <p>
          Review <code>pg_partman.part_template</code> to understand what indexes will be created on new partitions automatically. Customize templates to match your application's specific index requirements.
        </p>

        <h2>Migrating Existing Tables</h2>
        <p>
          Partitioning an existing large table requires care. Create a new partitioned table, copy data, then swap table names:
        </p>
        <pre><code>-- Create new partitioned table
CREATE TABLE events_partitioned LIKE events INCLUDING ALL;

-- Apply partitioning
SELECT pg_partman.create_parent(
  p_parent_table => 'public.events_partitioned',
  p_control => 'created_at',
  p_type => 'range',
  p_interval => 'daily'
);

-- Copy existing data
INSERT INTO events_partitioned SELECT * FROM events;

-- Swap table names
ALTER TABLE events RENAME TO events_old;
ALTER TABLE events_partitioned RENAME TO events;</code></pre>
        <p>
          After verifying data integrity, drop the old table. For massive tables, consider partitioning data in batches to reduce memory pressure and lock contention.
        </p>

        <h2>Conclusion</h2>
        <p>
          pg_partman transforms partition management from a manual maintenance burden into an automated system that scales effortlessly. By splitting large tables into manageable chunks and cleaning up old data systematically, it unlocks dramatic performance improvements for growing datasets.
        </p>
        <p>
          Whether you're handling time-series events, logs, or transactional history, pg_partman enables you to focus on application logic while your database infrastructure handles the complexity of scale automatically.
        </p>
      </div>

      <footer class="mt-16 pt-8 border-t border-slate-200">
        <a href="/blog.html" class="inline-flex items-center gap-2 px-6 py-3 border-2 border-blue-600 text-blue-600 font-medium rounded-lg hover:bg-blue-600 hover:text-white transition-colors">
          <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path>
          </svg>
          Back to All Posts
        </a>
      </footer>
    </div>
  </article>

  <script>
    // Mobile menu toggle
    const mobileMenuBtn = document.getElementById('mobile-menu-btn');
    const mobileMenu = document.getElementById('mobile-menu');

    mobileMenuBtn.addEventListener('click', () => {
      mobileMenu.classList.toggle('hidden');
    });
  </script>
</body>
</html>
