<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Understanding pg_repack: Eliminate PostgreSQL Table Bloat Without Downtime - B창gu Alexandru Bogdan</title>
  <meta name="description" content="Complete guide to pg_repack for PostgreSQL. Learn how to eliminate table and index bloat with minimal locking, understand the benefits over VACUUM FULL, and implement best practices for database maintenance." />

  <!-- PWA and Mobile -->
  <meta name="theme-color" content="#1e293b">

  <!-- JSON-LD Structured Data -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "headline": "Understanding pg_repack: Eliminate PostgreSQL Table Bloat Without Downtime",
    "description": "Complete guide to pg_repack for PostgreSQL. Learn how to eliminate table and index bloat with minimal locking, understand the benefits over VACUUM FULL, and implement best practices for database maintenance.",
    "image": "https://alexandrubagu.github.io/profile.jpg",
    "author": {
      "@type": "Person",
      "name": "B창gu Alexandru Bogdan",
      "url": "https://alexandrubagu.github.io"
    },
    "publisher": {
      "@type": "Person",
      "name": "B창gu Alexandru Bogdan",
      "logo": {
        "@type": "ImageObject",
        "url": "https://alexandrubagu.github.io/profile.jpg"
      }
    },
    "datePublished": "2025-12-03",
    "dateModified": "2025-12-03",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "https://alexandrubagu.github.io/blog/pg-repack-guide.html"
    },
    "keywords": "pg_repack, PostgreSQL bloat, database maintenance, VACUUM FULL alternative, PostgreSQL optimization, table bloat, index bloat, PostgreSQL performance",
    "articleSection": "Database",
    "inLanguage": "en-US",
    "about": [
      {
        "@type": "Thing",
        "name": "PostgreSQL Database"
      },
      {
        "@type": "Thing",
        "name": "Database Maintenance"
      },
      {
        "@type": "Thing",
        "name": "Performance Optimization"
      },
      {
        "@type": "Thing",
        "name": "pg_repack Extension"
      }
    ]
  }
  </script>

  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "TechArticle",
    "name": "pg_repack Database Maintenance Guide",
    "description": "Technical guide for using pg_repack to eliminate PostgreSQL table and index bloat without downtime",
    "proficiencyLevel": "Intermediate",
    "dependencies": "PostgreSQL, pg_repack extension",
    "author": {
      "@type": "Person",
      "name": "B창gu Alexandru Bogdan"
    }
  }
  </script>

  <!-- Performance optimizations -->
  <link rel="icon" href="/favicon.ico" sizes="any">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="dns-prefetch" href="https://cdn.tailwindcss.com">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">

  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: {
            sans: ['Inter', 'system-ui', 'sans-serif'],
          },
          colors: {
            primary: 'rgb(59, 130, 246)',
            'primary-foreground': 'rgb(255, 255, 255)',
            background: 'rgb(255, 255, 255)',
            foreground: 'rgb(30, 41, 59)',
            muted: 'rgb(241, 245, 249)',
            'muted-foreground': 'rgb(100, 116, 139)',
            border: 'rgb(226, 232, 240)',
            slate: {
              50: 'rgb(248, 250, 252)',
              100: 'rgb(241, 245, 249)',
              200: 'rgb(226, 232, 240)',
              300: 'rgb(203, 213, 225)',
              400: 'rgb(148, 163, 184)',
              500: 'rgb(100, 116, 139)',
              600: 'rgb(71, 85, 105)',
              700: 'rgb(51, 65, 85)',
              800: 'rgb(30, 41, 59)',
              900: 'rgb(15, 23, 42)',
            },
          },
        },
      },
    }
  </script>

  <style>
    html {
      scroll-behavior: smooth;
    }

    section {
      scroll-margin-top: 5rem;
    }

    .gradient-hero {
      background: linear-gradient(135deg, rgb(15, 23, 42) 0%, rgb(30, 41, 59) 100%);
    }

    .gradient-primary {
      background: linear-gradient(135deg, rgb(59, 130, 246) 0%, rgb(96, 165, 250) 100%);
    }

    .gradient-subtle {
      background: linear-gradient(180deg, rgb(255, 255, 255) 0%, rgb(248, 250, 252) 100%);
    }

    .line-clamp-2 {
      display: -webkit-box;
      -webkit-line-clamp: 2;
      line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    .line-clamp-3 {
      display: -webkit-box;
      -webkit-line-clamp: 3;
      line-clamp: 3;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    article code {
      background-color: #f1f5f9;
      padding: 0.125rem 0.5rem;
      border-radius: 0.25rem;
      font-size: 0.875rem;
    }

    article pre {
      background-color: #1e293b;
      color: #e2e8f0;
      padding: 1rem;
      border-radius: 0.5rem;
      overflow-x: auto;
      margin-bottom: 1rem;
    }

    article pre code {
      background-color: transparent;
      padding: 0;
      color: #e2e8f0;
      font-family: 'Courier New', monospace;
    }

    article h2 {
      font-size: 1.875rem;
      font-weight: 700;
      margin-top: 2rem;
      margin-bottom: 1rem;
      color: #1e293b;
    }

    article p {
      margin-bottom: 1rem;
      line-height: 1.75;
      color: #475569;
    }

    article ul {
      margin-left: 1.5rem;
      margin-bottom: 1rem;
    }

    article li {
      margin-bottom: 0.5rem;
      color: #475569;
      line-height: 1.75;
    }

    article strong {
      color: #1e293b;
      font-weight: 600;
    }
  </style>

  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-WK8MJ0B6R6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-WK8MJ0B6R6');
  </script>
</head>
<body class="bg-white text-slate-900">
  <!-- Navigation -->
  <nav id="navbar" class="fixed top-0 left-0 right-0 z-50 bg-white/95 backdrop-blur-md shadow-md transition-all duration-300">
    <div class="container mx-auto px-4">
      <div class="flex items-center justify-between h-16">
        <a href="/index.html" id="navbar-logo" class="text-xl font-bold text-slate-900 hover:text-primary transition-colors">
          Alexandru Bogdan
        </a>

        <!-- Desktop Navigation -->
        <div class="hidden md:flex items-center space-x-1" id="desktop-nav">
          <a href="/index.html#home" class="px-3 py-2 text-sm font-medium text-slate-900 hover:text-primary transition-colors">Home</a>
          <a href="/index.html#experience" class="px-3 py-2 text-sm font-medium text-slate-900 hover:text-primary transition-colors">Experience</a>
          <a href="/index.html#projects" class="px-3 py-2 text-sm font-medium text-slate-900 hover:text-primary transition-colors">Projects</a>
          <a href="/blog.html" class="px-3 py-2 text-sm font-medium text-slate-900 hover:text-primary transition-colors">Blog</a>
          <a href="/index.html#contact" class="px-3 py-2 text-sm font-medium text-slate-900 hover:text-primary transition-colors">Contact</a>
        </div>

        <!-- Mobile Menu Button -->
        <button id="mobile-menu-btn" class="md:hidden p-2 text-slate-900">
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
          </svg>
        </button>
      </div>

      <!-- Mobile Navigation -->
      <div id="mobile-menu" class="hidden md:hidden py-4 border-t border-slate-200">
        <div class="flex flex-col space-y-2" id="mobile-nav">
          <a href="/index.html#home" class="px-3 py-2 text-sm font-medium text-slate-900 hover:text-primary hover:bg-slate-100 rounded-md transition-colors">Home</a>
          <a href="/index.html#experience" class="px-3 py-2 text-sm font-medium text-slate-900 hover:text-primary hover:bg-slate-100 rounded-md transition-colors">Experience</a>
          <a href="/index.html#projects" class="px-3 py-2 text-sm font-medium text-slate-900 hover:text-primary hover:bg-slate-100 rounded-md transition-colors">Projects</a>
          <a href="/blog.html" class="px-3 py-2 text-sm font-medium text-slate-900 hover:text-primary hover:bg-slate-100 rounded-md transition-colors">Blog</a>
          <a href="/index.html#contact" class="px-3 py-2 text-sm font-medium text-slate-900 hover:text-primary hover:bg-slate-100 rounded-md transition-colors">Contact</a>
        </div>
      </div>
    </div>
  </nav>

  <article class="container mx-auto px-4 pt-24 pb-16">
    <div class="max-w-3xl mx-auto">
      <header class="mb-12">
        <span class="px-3 py-1 bg-slate-200 text-slate-700 text-xs rounded-full mb-4 inline-block">Database</span>
        <h1 class="text-4xl md:text-5xl font-bold mb-6 text-slate-900">
          Understanding pg_repack: Eliminate PostgreSQL Table Bloat Without Downtime
        </h1>
        <div class="flex items-center gap-6 text-slate-600">
          <div class="flex items-center gap-2">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
            </svg>
            <span class="text-sm">December 3, 2025</span>
          </div>
          <div class="flex items-center gap-2">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
            <span class="text-sm">6 min read</span>
          </div>
        </div>
      </header>

      <div class="prose max-w-none text-slate-900">
        <p class="mb-4 text-lg">
          Database bloat is a common challenge in PostgreSQL production environments. As tables undergo frequent updates and deletes, dead tuples accumulate and degrade performance. While VACUUM FULL can reclaim this space, it requires extensive locking that brings your application to a halt. This is where pg_repack shines: a PostgreSQL extension that eliminates bloat while keeping your database fully operational.
        </p>

        <h2>What is pg_repack?</h2>
        <p>
          pg_repack is a PostgreSQL extension designed to rebuild tables and indexes without blocking concurrent read and write operations. Unlike built-in maintenance commands, it operates as an external tool that connects to your database from an EC2 instance or local machine.
        </p>
        <p>
          The mechanism is elegant: pg_repack creates a fresh copy of your bloated table, tracks any changes happening during the rebuild, then swaps the old table with the optimized version. The critical advantage is that it only requires exclusive locks for brief moments at the beginning and end of the process.
        </p>

        <h2>Why Use pg_repack?</h2>
        <p>
          Standard PostgreSQL maintenance tools have significant limitations. VACUUM FULL reclaims space but locks your table for the entire operation, making it unsuitable for production environments. CLUSTER and REINDEX have similar drawbacks.
        </p>
        <p>
          pg_repack addresses these issues with three key benefits:
        </p>
        <ul>
          <li><strong>Minimal downtime:</strong> Tables remain accessible for reads and writes throughout the repacking process</li>
          <li><strong>Brief locking period:</strong> Exclusive locks are held only during initial setup and final swap operations</li>
          <li><strong>Operational flexibility:</strong> Run maintenance during business hours without impacting users</li>
        </ul>
        <p>
          This makes pg_repack essential for high-availability systems where traditional maintenance windows are impractical or impossible.
        </p>

        <h2>How pg_repack Works</h2>
        <p>
          Understanding the repacking process helps you use the tool effectively. Here's what happens under the hood:
        </p>
        <p>
          First, pg_repack creates a new empty table with the same schema as your original. It then copies all current rows from the bloated table to this fresh structure. While this bulk copy runs, a trigger captures any INSERT, UPDATE, or DELETE operations happening on the original table.
        </p>
        <p>
          These concurrent changes are stored in a log table. Once the initial copy completes, pg_repack applies the logged changes to bring the new table up to date. Finally, it briefly acquires an exclusive lock to swap table names, making the new optimized table live.
        </p>
        <p>
          The entire process runs without blocking normal database operations. Your application continues serving requests while pg_repack works in the background.
        </p>

        <h2>Installing and Using pg_repack</h2>
        <p>
          Before running pg_repack, you need to install the extension on your PostgreSQL server. For AWS RDS or Aurora, the extension is available but must be enabled. For self-hosted PostgreSQL, install via your package manager or build from source.
        </p>
        <p>
          Once installed, you can repack tables or indexes using command-line syntax:
        </p>
        <pre><code># Repack a specific table
pg_repack -h your-host.com -d mydatabase --table orders -k

# Repack an index
pg_repack -h your-host.com -d mydatabase --index idx_orders_customer</code></pre>
        <p>
          The <code>-k</code> flag ensures that only data is repacked without rebuilding indexes. This is faster when you only need to reclaim table bloat.
        </p>
        <p>
          For database-wide maintenance, you can repack all tables in a database:
        </p>
        <pre><code># Repack all tables in the database
pg_repack -h your-host.com -d mydatabase</code></pre>
        <p>
          This is useful for scheduled maintenance but requires more time and resources than targeting specific tables.
        </p>

        <h2>Important Limitations</h2>
        <p>
          pg_repack has several requirements and constraints to be aware of:
        </p>
        <ul>
          <li><strong>Primary keys required:</strong> Tables must have a primary key or unique index. pg_repack uses this to identify rows during the rebuild</li>
          <li><strong>No temporary tables:</strong> The tool cannot operate on temporary tables</li>
          <li><strong>No global indexes:</strong> Tables with global indexes (in partitioned scenarios) are not supported</li>
          <li><strong>DDL blocking:</strong> Schema changes on the target table are blocked during repacking</li>
        </ul>
        <p>
          These limitations are important for planning your maintenance strategy. If a table lacks a primary key, you'll need to add one before running pg_repack.
        </p>

        <h2>Handling Invalid Indexes</h2>
        <p>
          One common issue is the <code>error-on-invalid-index</code> warning. This indicates corrupted or failed index builds that pg_repack refuses to process. Attempting to repack with invalid indexes could lead to data inconsistencies.
        </p>
        <p>
          To identify invalid indexes on a table, run this query:
        </p>
        <pre><code>SELECT indexrelid::regclass, indisvalid
FROM pg_index
WHERE indrelid = 'orders'::regclass
  AND NOT indisvalid;</code></pre>
        <p>
          If you find invalid indexes, drop them before proceeding:
        </p>
        <pre><code>DROP INDEX CONCURRENTLY idx_invalid_name;</code></pre>
        <p>
          After removing invalid indexes, pg_repack will run successfully. You can rebuild the indexes afterward using <code>CREATE INDEX CONCURRENTLY</code>.
        </p>

        <h2>Best Practices</h2>
        <p>
          To get the most from pg_repack, follow these guidelines:
        </p>
        <ul>
          <li>Monitor bloat levels regularly using queries against <code>pg_stat_user_tables</code> to identify candidates for repacking</li>
          <li>Target specific tables rather than repacking entire databases unless necessary</li>
          <li>Run pg_repack during lower-traffic periods when possible to reduce resource contention</li>
          <li>Ensure adequate disk space - pg_repack needs space for both the old and new table simultaneously</li>
          <li>Test the operation on development or staging environments first to estimate duration and resource usage</li>
        </ul>
        <p>
          For large tables, consider the <code>--no-order</code> flag to skip clustering by index, which speeds up the process when logical order isn't critical.
        </p>

        <h2>When to Choose pg_repack Over Alternatives</h2>
        <p>
          pg_repack isn't always the answer. Use VACUUM regularly for routine maintenance - it prevents bloat from accumulating in the first place. VACUUM FULL is acceptable during scheduled maintenance windows when brief downtime is tolerable.
        </p>
        <p>
          Choose pg_repack when you need to reclaim significant bloat on production tables that must remain online. It's particularly valuable for high-traffic tables in 24/7 applications where traditional maintenance windows don't exist.
        </p>
        <p>
          For tables that rarely change, bloat may not be an issue at all. Focus pg_repack efforts on frequently updated tables where dead tuples accumulate quickly.
        </p>

        <h2>Monitoring and Verification</h2>
        <p>
          After running pg_repack, verify the operation succeeded by checking table sizes:
        </p>
        <pre><code>SELECT
  schemaname,
  tablename,
  pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size
FROM pg_tables
WHERE tablename = 'orders';</code></pre>
        <p>
          Compare the size before and after repacking to confirm bloat was eliminated. You should see a significant reduction for heavily bloated tables.
        </p>
        <p>
          Monitor system resources during repacking to ensure it doesn't overwhelm your database server. pg_repack is I/O intensive and can impact query performance if resources are constrained.
        </p>

        <h2>Conclusion</h2>
        <p>
          pg_repack is an essential tool for maintaining PostgreSQL databases in production environments. By eliminating table and index bloat without blocking concurrent operations, it enables effective maintenance without sacrificing availability.
        </p>
        <p>
          Understanding its capabilities and limitations allows you to incorporate pg_repack into your database maintenance strategy effectively. Regular monitoring identifies bloat early, and targeted repacking keeps your database performing optimally without impacting users.
        </p>
      </div>

      <footer class="mt-16 pt-8 border-t border-slate-200">
        <a href="/blog.html" class="inline-flex items-center gap-2 px-6 py-3 border-2 border-blue-600 text-blue-600 font-medium rounded-lg hover:bg-blue-600 hover:text-white transition-colors">
          <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path>
          </svg>
          Back to All Posts
        </a>
      </footer>
    </div>
  </article>

  <script>
    // Mobile menu toggle
    const mobileMenuBtn = document.getElementById('mobile-menu-btn');
    const mobileMenu = document.getElementById('mobile-menu');

    mobileMenuBtn.addEventListener('click', () => {
      mobileMenu.classList.toggle('hidden');
    });
  </script>
</body>
</html>